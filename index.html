<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Captcha Solver (Tesseract.js)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0b0c10;
      --fg: #c5c6c7;
      --accent: #66fcf1;
      --muted: #7f8c8d;
      --card: #1f2833;
      --border: #2c3e50;
      --good: #2ecc71;
      --warn: #f1c40f;
      --bad: #e74c3c;
    }
    html, body {
      margin: 0; padding: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; 
      background: var(--bg); color: var(--fg);
    }
    .container {
      max-width: 980px; margin: 0 auto; padding: 24px 16px 64px;
    }
    header {
      display: flex; align-items: center; justify-content: space-between; gap: 16px; flex-wrap: wrap;
    }
    h1 { font-size: 1.6rem; margin: 0; }
    .card {
      background: var(--card); border: 1px solid var(--border); border-radius: 12px;
      padding: 16px; margin-top: 16px;
    }
    label { font-weight: 600; display: block; margin-bottom: 6px; }
    input[type="url"], input[type="text"] {
      width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid var(--border);
      background: transparent; color: var(--fg);
    }
    .row { display: grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 800px) {
      .row { grid-template-columns: 2.2fr 1.8fr; }
    }
    .actions { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
    button {
      appearance: none; border: 1px solid var(--border); background: transparent; color: var(--fg);
      padding: 10px 14px; border-radius: 10px; cursor: pointer; font-weight: 600;
    }
    button.primary { background: var(--accent); color: #000; border-color: transparent; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    .muted { color: var(--muted); font-size: 0.95rem; }
    .meta {
      display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 8px; margin-top: 8px;
    }
    .kv { background: rgba(255,255,255,0.03); border: 1px dashed var(--border); border-radius: 10px; padding: 8px 10px; overflow: hidden; }
    .kv .k { color: var(--muted); font-size: 0.85rem; }
    .kv .v { font-weight: 700; word-break: break-all; }
    .preview {
      display: grid; grid-template-columns: 1fr; gap: 12px;
    }
    .imgWrap { background: #fff; border-radius: 8px; overflow: auto; border: 1px solid var(--border); display: grid; place-items: center; padding: 8px; }
    .imgWrap img, .imgWrap canvas { max-width: 100%; image-rendering: pixelated; }
    .status {
      padding: 8px 10px; border-radius: 10px; background: rgba(255,255,255,0.05); border: 1px solid var(--border);
      display: flex; justify-content: space-between; align-items: center; gap: 10px;
    }
    .status .chip { padding: 4px 8px; border-radius: 999px; font-weight: 700; }
    .chip.ok { background: rgba(46, 204, 113, 0.15); color: var(--good); border: 1px solid rgba(46, 204, 113, 0.4); }
    .chip.warn { background: rgba(241, 196, 15, 0.15); color: var(--warn); border: 1px solid rgba(241, 196, 15, 0.4); }
    .chip.err { background: rgba(231, 76, 60, 0.15); color: var(--bad); border: 1px solid rgba(231, 76, 60, 0.4); }
    .logs {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: #0a0a0a; color: #bdbdbd; border-radius: 10px; padding: 10px; border: 1px solid #191919; height: 180px; overflow: auto;
    }
    .small { font-size: 0.85rem; }
    footer { margin-top: 32px; color: var(--muted); }
    a, a:visited { color: var(--accent); text-decoration: none; }
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Captcha Solver</h1>
      <div class="muted small">Client-side OCR using Tesseract.js</div>
    </header>

    <div class="card">
      <label for="urlInput">Captcha image URL (?url=...)</label>
      <input id="urlInput" type="url" placeholder="https://example.com/captcha.png" />
      <div class="actions">
        <button id="loadBtn">Load</button>
        <button id="solveBtn" class="primary">Solve</button>
        <button id="resetBtn">Reset</button>
      </div>
      <div class="meta">
        <div class="kv">
          <div class="k">Current URL</div>
          <div class="v" id="currentUrl">—</div>
        </div>
        <div class="kv">
          <div class="k">Status</div>
          <div class="v" id="statusText">Idle</div>
        </div>
        <div class="kv">
          <div class="k">Result</div>
          <div class="v" id="resultText">—</div>
        </div>
        <div class="kv">
          <div class="k">Confidence</div>
          <div class="v" id="confidenceText">—</div>
        </div>
        <div class="kv">
          <div class="k">Elapsed</div>
          <div class="v" id="elapsedText">0.00s</div>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="card preview">
        <div class="status">
          <div>
            <div class="small muted">Original</div>
            <strong>Captcha Preview</strong>
          </div>
          <span id="imgChip" class="chip warn">Waiting</span>
        </div>
        <div class="imgWrap"><img id="captchaImg" alt="captcha" crossorigin="anonymous" referrerpolicy="no-referrer"></div>
        <div class="small muted">Tip: Ensure the image server supports CORS for OCR. If not, download and open locally, or use a CORS-enabled URL.</div>
      </div>

      <div class="card preview">
        <div class="status">
          <div>
            <div class="small muted">Preprocessed</div>
            <strong>Binary Image</strong>
          </div>
          <span id="prepChip" class="chip warn">Pending</span>
        </div>
        <div class="imgWrap"><canvas id="prepCanvas"></canvas></div>
        <div class="logs" id="logs"></div>
      </div>
    </div>

    <footer class="small">
      MIT License. No data leaves your browser. This demo uses Tesseract.js and performs optional preprocessing (grayscale + Otsu threshold) for improved accuracy.
    </footer>
  </div>

  <script src="https://unpkg.com/tesseract.js@v5.1.0/dist/tesseract.min.js"></script>
  <script>
    // Default inline SVG captcha (safe local data URL)
    const defaultCaptchaText = "X7Y9";
    const defaultSvg = `
      <svg xmlns="http://www.w3.org/2000/svg" width="220" height="90">
        <defs>
          <filter id="s" x="-10%" y="-10%" width="120%" height="120%">
            <feOffset dx="1" dy="1"/><feGaussianBlur stdDeviation="0.4"/>
          </filter>
        </defs>
        <rect width="100%" height="100%" fill="white" />
        <g font-family="monospace" font-weight="700" font-size="54" fill="#111">
          <text x="18" y="60" filter="url(#s)">${defaultCaptchaText}</text>
        </g>
        <g stroke="#888" stroke-width="1" opacity="0.35">
          <line x1="0" y1="10" x2="220" y2="12"/>
          <line x1="0" y1="40" x2="220" y2="42"/>
          <line x1="0" y1="70" x2="220" y2="68"/>
        </g>
        <g fill="#aaa" opacity="0.2">
          <circle cx="50" cy="20" r="3"/>
          <circle cx="120" cy="50" r="2"/>
          <circle cx="180" cy="30" r="2.5"/>
        </g>
      </svg>`;
    const defaultUrl = "data:image/svg+xml;utf8," + encodeURIComponent(defaultSvg);

    const dom = {
      urlInput: document.getElementById('urlInput'),
      loadBtn: document.getElementById('loadBtn'),
      solveBtn: document.getElementById('solveBtn'),
      resetBtn: document.getElementById('resetBtn'),
      currentUrl: document.getElementById('currentUrl'),
      statusText: document.getElementById('statusText'),
      resultText: document.getElementById('resultText'),
      confidenceText: document.getElementById('confidenceText'),
      elapsedText: document.getElementById('elapsedText'),
      img: document.getElementById('captchaImg'),
      imgChip: document.getElementById('imgChip'),
      prepChip: document.getElementById('prepChip'),
      prepCanvas: document.getElementById('prepCanvas'),
      logs: document.getElementById('logs'),
    };

    const qs = new URLSearchParams(location.search);
    const initialUrl = qs.get('url') || defaultUrl;

    let workerPromise = null;
    let solving = false;
    let startTime = 0;

    function setStatus(text) { dom.statusText.textContent = text; }
    function setResult(text) { dom.resultText.textContent = text || '—'; }
    function setConf(v) { dom.confidenceText.textContent = (v || v === 0) ? `${v.toFixed(1)}%` : '—'; }
    function setElapsed() {
      if (!startTime) return;
      const dt = (performance.now() - startTime) / 1000;
      dom.elapsedText.textContent = `${dt.toFixed(2)}s`;
    }
    function log(...args) {
      const line = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
      dom.logs.textContent += (dom.logs.textContent ? "\n" : "") + line;
      dom.logs.scrollTop = dom.logs.scrollHeight;
      // also console
      console.log(...args);
    }
    function setChip(el, type, text) {
      el.className = `chip ${type}`;
      el.textContent = text;
    }

    function updateUrl(url) {
      dom.urlInput.value = url;
      dom.currentUrl.textContent = url;
      try {
        const u = new URL(location.href);
        u.searchParams.set('url', url);
        history.replaceState(null, '', u.toString());
      } catch {}
    }

    // Preprocessing utilities
    function drawToCanvas(img) {
      const c = dom.prepCanvas;
      const ctx = c.getContext('2d', { willReadFrequently: true });
      c.width = img.naturalWidth || img.width;
      c.height = img.naturalHeight || img.height;
      ctx.drawImage(img, 0, 0);
      return c;
    }
    function toGrayscale(imgData) {
      const d = imgData.data;
      for (let i = 0; i < d.length; i += 4) {
        const r = d[i], g = d[i+1], b = d[i+2];
        const y = (0.299*r + 0.587*g + 0.114*b) | 0;
        d[i] = d[i+1] = d[i+2] = y;
      }
      return imgData;
    }
    function otsuThreshold(grayData) {
      // grayData: ImageData with R=G=B
      const d = grayData.data;
      const hist = new Uint32Array(256);
      const total = d.length / 4;
      for (let i = 0; i < d.length; i += 4) hist[d[i]]++;
      let sum = 0;
      for (let t = 0; t < 256; t++) sum += t * hist[t];
      let sumB = 0, wB = 0, wF = 0, varMax = 0, threshold = 127;
      for (let t = 0; t < 256; t++) {
        wB += hist[t];
        if (wB === 0) continue;
        wF = total - wB;
        if (wF === 0) break;
        sumB += t * hist[t];
        const mB = sumB / wB;
        const mF = (sum - sumB) / wF;
        const varBetween = wB * wF * (mB - mF) * (mB - mF);
        if (varBetween > varMax) {
          varMax = varBetween;
          threshold = t;
        }
      }
      return threshold;
    }
    function applyThreshold(imgData, t, invert=false) {
      const d = imgData.data;
      for (let i = 0; i < d.length; i += 4) {
        const v = d[i]; // gray
        let on = v <= t;
        if (invert) on = !on;
        const px = on ? 0 : 255; // black text on white background by default
        d[i] = d[i+1] = d[i+2] = px;
        d[i+3] = 255;
      }
      return imgData;
    }

    async function ensureWorker() {
      if (!workerPromise) {
        workerPromise = (async () => {
          setStatus('Loading OCR engine...');
          log('[init] Loading Tesseract worker and language data...');
          const worker = await Tesseract.createWorker({
            logger: m => {
              if (m.status) log(`[tess] ${m.status} ${m.progress ? (Math.round(m.progress * 100) + '%') : ''}`);
            },
            // Use public CDNs for core and lang (eng)
            langPath: 'https://tessdata.projectnaptha.com/4.0.0',
            // corePath auto-resolves via CDN
          });
          await worker.loadLanguage('eng');
          await worker.initialize('eng');
          // Defaults optimized for single-line captchas
          await worker.setParameters({
            tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
            tessedit_pageseg_mode: '7', // single text line
          });
          log('[init] Worker ready');
          setStatus('OCR ready');
          return worker;
        })();
      }
      return workerPromise;
    }

    function getAlnum(s) {
      return (s || '').replace(/[^A-Za-z0-9]/g, '');
    }

    function plausible(text) {
      const t = getAlnum(text);
      return t.length >= 3 && t.length <= 10;
    }

    async function recognizeWith(worker, source, params={}) {
      if (params.psm) {
        await worker.setParameters({ tessedit_pageseg_mode: String(params.psm) });
      }
      if (params.whitelist) {
        await worker.setParameters({ tessedit_char_whitelist: params.whitelist });
      }
      const { data } = await worker.recognize(source);
      return data;
    }

    async function preprocessAndShow(imgEl) {
      try {
        const canvas = drawToCanvas(imgEl);
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        let data = ctx.getImageData(0, 0, canvas.width, canvas.height);
        data = toGrayscale(data);
        const t = otsuThreshold(data);
        data = applyThreshold(data, t, false); // black text on white
        ctx.putImageData(data, 0, 0);
        setChip(dom.prepChip, 'ok', 'Thresholded');
        log(`[prep] Otsu threshold = ${t}`);
        return canvas;
      } catch (e) {
        setChip(dom.prepChip, 'err', 'Preprocess failed');
        log('[prep] Failed:', e.message || e);
        return null;
      }
    }

    async function solve() {
      if (solving) return;
      solving = true;
      startTime = performance.now();
      dom.elapsedText.textContent = '0.00s';
      setResult('—');
      setConf(null);
      setStatus('Solving...');
      setChip(dom.imgChip, 'ok', 'Loaded');
      setChip(dom.prepChip, 'warn', 'Pending');
      dom.logs.textContent = '';
      const elapsedTicker = setInterval(setElapsed, 100);

      try {
        const worker = await ensureWorker();
        const prepCanvas = await preprocessAndShow(dom.img);

        const attempts = [];
        if (prepCanvas) {
          attempts.push({ src: prepCanvas, psm: 7, label: 'threshold psm7' });
          attempts.push({ src: prepCanvas, psm: 8, label: 'threshold psm8' });
        }
        // Fallback to original if preprocessing failed or not good
        attempts.push({ src: dom.img.src, psm: 7, label: 'original psm7' });
        attempts.push({ src: dom.img.src, psm: 8, label: 'original psm8' });

        const deadline = performance.now() + 15000; // 15 seconds
        let best = { text: '', conf: 0, raw: null };
        for (let i = 0; i < attempts.length; i++) {
          if (performance.now() > deadline) { log('[solve] Deadline reached'); break; }
          const a = attempts[i];
          log(`[solve] Attempt ${i+1}/${attempts.length}: ${a.label}`);
          try {
            const data = await recognizeWith(worker, a.src, { psm: a.psm });
            const text = getAlnum(data.text);
            const conf = data.confidence || 0;
            log(`[solve] -> "${text}" (conf ${conf.toFixed(1)}%)`);
            if (conf > best.conf) {
              best = { text, conf, raw: data };
            }
            if (plausible(text) && conf >= 50) {
              best = { text, conf, raw: data };
              log('[solve] Early accept');
              break;
            }
          } catch (e) {
            log(`[solve] Attempt failed: ${e.message || e}`);
          }
        }

        const elapsed = (performance.now() - startTime) / 1000;
        setResult(best.text || '(no result)');
        setConf(best.conf || 0);
        setStatus(best.text ? 'Solved' : 'No result');
        log(`[done] Finished in ${elapsed.toFixed(2)}s`);
      } catch (err) {
        setStatus('Error');
        setChip(dom.prepChip, 'err', 'Error');
        log('[error]', err.message || err);
      } finally {
        clearInterval(elapsedTicker);
        setElapsed();
        solving = false;
      }
    }

    async function loadImage(url) {
      return new Promise((resolve, reject) => {
        dom.img.onload = () => resolve(true);
        dom.img.onerror = (e) => reject(e);
        dom.img.src = url;
      });
    }

    function setUIState(loading) {
      dom.loadBtn.disabled = loading;
      dom.solveBtn.disabled = loading;
      dom.resetBtn.disabled = loading;
    }

    async function initLoad(url) {
      setUIState(true);
      setStatus('Loading image...');
      setResult('—'); setConf(null);
      setChip(dom.imgChip, 'warn', 'Loading');
      setChip(dom.prepChip, 'warn', 'Pending');
      dom.logs.textContent = '';
      dom.prepCanvas.width = dom.prepCanvas.height = 0;

      try {
        updateUrl(url);
        await loadImage(url);
        setChip(dom.imgChip, 'ok', 'Loaded');
        setStatus('Image ready');
      } catch (e) {
        setChip(dom.imgChip, 'err', 'Load failed');
        setStatus('Image failed to load');
        log('[img] Load error:', e.message || e);
      } finally {
        setUIState(false);
      }
    }

    // Wire up UI
    dom.loadBtn.addEventListener('click', async () => {
      await initLoad(dom.urlInput.value.trim());
    });
    dom.solveBtn.addEventListener('click', async () => {
      if (!dom.img.src) return;
      await solve();
    });
    dom.resetBtn.addEventListener('click', async () => {
      await initLoad(defaultUrl);
      await solve();
    });

    // Initialize
    (async function boot() {
      dom.urlInput.value = initialUrl;
      updateUrl(initialUrl);
      await initLoad(initialUrl);
      // Auto-solve on boot
      await ensureWorker();
      await solve();
    })();
  </script>
</body>
</html>