<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Captcha Solver (Client-side OCR)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      color-scheme: light dark;
    }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      margin: 0;
      padding: 16px;
      display: grid;
      gap: 16px;
      background: #0b0c10;
      color: #e8e8e8;
    }
    header {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
    }
    h1 {
      font-size: 1.25rem;
      margin: 0;
    }
    .card {
      background: #14161b;
      border: 1px solid #222531;
      border-radius: 10px;
      padding: 14px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.15);
    }
    label {
      font-size: 0.9rem;
      opacity: 0.9;
      display: block;
      margin-bottom: 6px;
    }
    input[type="url"], input[type="text"] {
      width: 100%;
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid #2a2f3a;
      background: #0f1116;
      color: #e8e8e8;
      outline: none;
    }
    input[type="url"]:focus, input[type="text"]:focus {
      border-color: #5b8cff;
      box-shadow: 0 0 0 3px rgba(91,140,255,0.18);
    }
    .row {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }
    @media (min-width: 900px) {
      .row {
        grid-template-columns: 1.2fr 1fr;
      }
    }
    .buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    button {
      padding: 10px 14px;
      border-radius: 8px;
      border: 1px solid #2a2f3a;
      background: #1a1f2b;
      color: #e8e8e8;
      cursor: pointer;
    }
    button.primary {
      background: #5b8cff;
      border-color: #5b8cff;
      color: white;
    }
    button:hover {
      filter: brightness(1.05);
    }
    .img-wrap {
      display: grid;
      place-items: center;
      min-height: 120px;
      border: 1px dashed #2a2f3a;
      border-radius: 10px;
      background: #0f1116;
      padding: 10px;
    }
    .img-wrap img, .img-wrap canvas {
      max-width: 100%;
      image-rendering: pixelated;
    }
    .status {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.95rem;
      color: #aeb8ff;
      white-space: pre-wrap;
      min-height: 1.2em;
    }
    .solution {
      font-size: 1.6rem;
      font-weight: 700;
      letter-spacing: 2px;
      padding: 10px 12px;
      border-radius: 8px;
      background: #0f1116;
      border: 1px solid #2a2f3a;
      color: #75ffa7;
      text-align: center;
    }
    .hint {
      font-size: 0.85rem;
      opacity: 0.8;
    }
    .hidden {
      display: none !important;
    }
    footer {
      opacity: 0.7;
      font-size: 0.85rem;
    }
    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
  </style>
  <script src="https://unpkg.com/ocrad.js/ocrad.js"></script>
</head>
<body>
  <header>
    <h1>Captcha Solver</h1>
    <div class="hint">Pass an image URL via ?url=https://.../image.png</div>
  </header>

  <section class="card">
    <div class="row">
      <div>
        <label for="url">Captcha image URL</label>
        <input id="url" type="url" placeholder="https://example.com/captcha.png" />
        <div class="buttons" style="margin-top:8px;">
          <button class="primary" id="loadBtn">Load & Solve</button>
          <button id="solveBtn">Re-solve</button>
          <button id="sampleBtn">Use Sample</button>
        </div>
        <div class="hint" style="margin-top:6px;">
          Tip: Remote images should allow CORS for in-browser OCR. If they don't, download the image and open locally.
        </div>
      </div>
      <div>
        <label>Output</label>
        <div class="grid-2">
          <div class="solution" id="solution">—</div>
          <div class="status" id="status">Idle</div>
        </div>
      </div>
    </div>
  </section>

  <section class="card">
    <div class="row">
      <div>
        <label>Captcha image</label>
        <div class="img-wrap">
          <img id="img" alt="captcha" crossOrigin="anonymous" />
        </div>
        <div class="hint" style="margin-top:6px;">Displayed image will be processed in-browser (no server upload).</div>
      </div>
      <div>
        <label>Processing preview</label>
        <div class="img-wrap">
          <canvas id="preview" width="10" height="10"></canvas>
        </div>
        <div class="buttons" style="margin-top:8px;">
          <button id="togglePreview">Toggle Preview</button>
          <button id="downloadCanvas">Download Processed</button>
        </div>
      </div>
    </div>
  </section>

  <footer>
    MIT License. Client-side OCR using OCRAD.js with adaptive thresholding and morphology to improve captcha legibility.
  </footer>

  <script>
    // Utilities
    const qs = new URLSearchParams(location.search);
    const $ = (id) => document.getElementById(id);
    const urlInput = $('url');
    const img = $('img');
    const solutionEl = $('solution');
    const statusEl = $('status');
    const previewCanvas = $('preview');
    const pctx = previewCanvas.getContext('2d', { willReadFrequently: true });

    let lastVariants = [];
    let abortSolve = { flag: false };

    function setStatus(msg) {
      statusEl.textContent = msg;
    }
    function setSolution(text) {
      solutionEl.textContent = text || '—';
    }

    // Default sample generator (no external dependency)
    function generateSampleCaptcha(text = null, width = 240, height = 90) {
      const c = document.createElement('canvas');
      c.width = width; c.height = height;
      const ctx = c.getContext('2d');

      // Background
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, width, height);

      // Light noise
      for (let i = 0; i < 80; i++) {
        ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.08})`;
        ctx.beginPath();
        ctx.arc(Math.random() * width, Math.random() * height, Math.random() * 2 + 0.5, 0, Math.PI * 2);
        ctx.fill();
      }

      // Random text if not provided
      if (!text) {
        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
        text = Array.from({length: 5}, () => chars[Math.floor(Math.random()*chars.length)]).join('');
      }

      // Draw guide lines
      ctx.lineWidth = 1.5;
      for (let i = 0; i < 2; i++) {
        ctx.strokeStyle = `rgba(0,0,0,${0.15 + Math.random()*0.1})`;
        ctx.beginPath();
        ctx.moveTo(0, Math.random() * height);
        for (let x = 0; x <= width; x += 8) {
          const y = height/2 + Math.sin((x/width)*Math.PI*2*(1+i)) * (height/6) + (Math.random()-0.5)*4;
          if (x === 0) ctx.moveTo(0, y);
          ctx.lineTo(x, y);
        }
        ctx.stroke();
      }

      // Text
      ctx.save();
      ctx.font = 'bold 42px monospace';
      ctx.textBaseline = 'middle';
      const xStart = 24;
      const spacing = (width - 48) / text.length;
      for (let i = 0; i < text.length; i++) {
        const ch = text[i];
        ctx.save();
        const x = xStart + i * spacing + (Math.random()-0.5)*6;
        const y = height/2 + (Math.random()-0.5)*6;
        const angle = (Math.random()-0.5) * 0.25; // small rotation
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.fillStyle = '#000000';
        ctx.fillText(ch, 0, 4);
        ctx.restore();
      }
      ctx.restore();

      // Foreground speckles
      for (let i = 0; i < 30; i++) {
        ctx.fillStyle = `rgba(0,0,0,${0.25 + Math.random()*0.15})`;
        ctx.fillRect(Math.random()*width, Math.random()*height, 1, 1);
      }

      const dataUrl = c.toDataURL('image/png');
      return { dataUrl, text };
    }

    function clamp(v, lo, hi) { return v < lo ? lo : (v > hi ? hi : v); }

    // Image Processing
    function toGray(imageData) {
      const d = imageData.data;
      for (let i = 0; i < d.length; i += 4) {
        const r = d[i], g = d[i+1], b = d[i+2];
        const y = (0.2126*r + 0.7152*g + 0.0722*b);
        d[i] = d[i+1] = d[i+2] = y;
      }
      return imageData;
    }

    function applyContrastBrightness(imageData, contrast = 1.2, brightness = 0) {
      const d = imageData.data;
      const c = contrast;
      const b = brightness;
      for (let i = 0; i < d.length; i += 4) {
        let v = d[i] * c + b;
        v = clamp(v, 0, 255);
        d[i] = d[i+1] = d[i+2] = v;
      }
      return imageData;
    }

    function otsuThreshold(grayData) {
      // Expect grayscale ImageData
      const d = grayData.data;
      const hist = new Array(256).fill(0);
      let total = 0;
      for (let i = 0; i < d.length; i += 4) {
        hist[d[i]|0]++;
        total++;
      }
      let sum = 0;
      for (let i = 0; i < 256; i++) sum += i * hist[i];
      let sumB = 0;
      let wB = 0;
      let varMax = -1;
      let threshold = 127;
      for (let i = 0; i < 256; i++) {
        wB += hist[i];
        if (wB === 0) continue;
        const wF = total - wB;
        if (wF === 0) break;
        sumB += i * hist[i];
        const mB = sumB / wB;
        const mF = (sum - sumB) / wF;
        const between = wB * wF * (mB - mF) * (mB - mF);
        if (between > varMax) {
          varMax = between;
          threshold = i;
        }
      }
      return threshold;
    }

    function binarize(grayData, thr = 128, invert = false) {
      const d = grayData.data;
      const t = thr|0;
      for (let i = 0; i < d.length; i += 4) {
        const v = d[i];
        let out = v > t ? 255 : 0;
        if (invert) out = 255 - out;
        d[i] = d[i+1] = d[i+2] = out;
      }
      return grayData;
    }

    function copyImageData(ctx, src) {
      const cpy = ctx.createImageData(src.width, src.height);
      cpy.data.set(src.data);
      return cpy;
    }

    function morph3x3(binaryImgData, width, height, op = 'dilate') {
      // binary image with pixel values 0 or 255
      const src = binaryImgData.data;
      const out = new Uint8ClampedArray(src.length);
      const isDilate = op === 'dilate';
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let hit = isDilate ? 0 : 1;
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              const xx = x + dx;
              const yy = y + dy;
              if (xx < 0 || yy < 0 || xx >= width || yy >= height) continue;
              const idx = (yy * width + xx) * 4;
              const v = src[idx] > 127 ? 1 : 0;
              if (isDilate) {
                hit = hit || v;
              } else {
                hit = hit && v;
              }
            }
          }
          const i4 = (y * width + x) * 4;
          const val = hit ? 255 : 0;
          out[i4] = out[i4+1] = out[i4+2] = val;
          out[i4+3] = 255;
        }
      }
      const res = new ImageData(out, width, height);
      return res;
    }

    function scaleTo(canvas, targetW, targetH) {
      const out = document.createElement('canvas');
      out.width = targetW;
      out.height = targetH;
      const ctx = out.getContext('2d');
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(canvas, 0, 0, targetW, targetH);
      return out;
    }

    function drawToCanvas(imageEl) {
      const c = document.createElement('canvas');
      c.width = imageEl.naturalWidth || imageEl.width;
      c.height = imageEl.naturalHeight || imageEl.height;
      const ctx = c.getContext('2d', { willReadFrequently: true });
      ctx.drawImage(imageEl, 0, 0);
      return c;
    }

    // OCR Pipeline
    function postprocessText(t) {
      if (!t) return '';
      // Normalize: remove whitespace and punctuation often misread
      t = t.replace(/\s+/g, '');
      t = t.replace(/[|!;:'",.<>()[\]{}]/g, '');
      // Standardize ambiguous characters
      t = t.replace(/[\u2018\u2019\u0060]/g, '');
      // OCR common confusion fixes
      t = t.replace(/§/g, 'S').replace(/\$/g, 'S');
      t = t.replace(/@/g, 'A');
      t = t.replace(/\?/g, '7');
      // Zero/O confusion
      t = t.replace(/Ø|⭕|○|◯|°|•/g, 'O');
      // One/l/I confusion
      t = t.replace(/[|]/g, 'I').replace(/!/, 'I');
      t = t.toUpperCase();
      t = t.replace(/[^A-Z0-9]/g, '');
      return t;
    }

    function scoreText(t) {
      if (!t) return -1e6;
      let score = 0;
      const len = t.length;
      // Ideal captcha length usually 4-7
      if (len >= 4 && len <= 7) score += 20;
      else score -= Math.abs(5 - len) * 3;

      // Alnum ratio
      const alnum = (t.match(/[A-Z0-9]/g) || []).length;
      score += alnum * 2;

      // Penalize repetition excessively
      const unique = new Set(t.split('')).size;
      score += unique * 1.5;

      // Slightly prefer having digits present
      if (/[0-9]/.test(t)) score += 3;

      return score;
    }

    function prepareVariants(baseCanvas) {
      const ctx = baseCanvas.getContext('2d', { willReadFrequently: true });
      const w = baseCanvas.width, h = baseCanvas.height;
      const src = ctx.getImageData(0, 0, w, h);

      const work = document.createElement('canvas');
      work.width = w; work.height = h;
      const wctx = work.getContext('2d', { willReadFrequently: true });

      function canvasFrom(imageData) {
        const c = document.createElement('canvas');
        c.width = imageData.width; c.height = imageData.height;
        c.getContext('2d').putImageData(imageData, 0, 0);
        return c;
      }

      // Build variants
      const variants = [];
      const gray = copyImageData(wctx, src);
      toGray(gray);
      variants.push({ name: 'gray+contrast1.2', canvas: (function(){
        const g = copyImageData(wctx, gray);
        applyContrastBrightness(g, 1.2, 0);
        return canvasFrom(g);
      })() });

      // Otsu binarization
      const g2 = copyImageData(wctx, gray);
      const t = otsuThreshold(g2);
      binarize(g2, t, false);
      variants.push({ name: `otsu(${t})`, canvas: canvasFrom(g2) });

      // Inverted Otsu
      const g3 = copyImageData(wctx, gray);
      binarize(g3, t, true);
      variants.push({ name: `otsu-inv(${t})`, canvas: canvasFrom(g3) });

      // Fixed thresholds
      [160, 128, 96].forEach(th => {
        const gf = copyImageData(wctx, gray);
        binarize(gf, th, false);
        variants.push({ name: `th-${th}`, canvas: canvasFrom(gf) });
      });

      // Morphology on Otsu
      const mDilate = morph3x3(g2, w, h, 'dilate');
      variants.push({ name: 'otsu+dilate', canvas: canvasFrom(mDilate) });
      const mErode = morph3x3(g2, w, h, 'erode');
      variants.push({ name: 'otsu+erode', canvas: canvasFrom(mErode) });

      // Scale up to help OCR
      const scales = [1.5, 2.0];
      const baseSet = variants.slice();
      baseSet.forEach(v => {
        scales.forEach(s => {
          const cScaled = scaleTo(v.canvas, Math.round(v.canvas.width * s), Math.round(v.canvas.height * s));
          variants.push({ name: `${v.name}+scale${s}`, canvas: cScaled });
        });
      });

      return variants;
    }

    function showPreview(canvas) {
      if (!canvas) return;
      previewCanvas.width = canvas.width;
      previewCanvas.height = canvas.height;
      pctx.imageSmoothingEnabled = false;
      pctx.drawImage(canvas, 0, 0);
    }

    async function solveCanvasWithVariants(variants, onProgress, abortRef) {
      let best = { text: '', score: -1e9, name: '' };
      let shownPreview = false;

      // Try early-show strategy: if score decent, update UI immediately
      for (let i = 0; i < variants.length; i++) {
        if (abortRef.flag) break;
        const v = variants[i];
        try {
          const tRaw = OCRAD(v.canvas);
          const t = postprocessText(tRaw);
          const s = scoreText(t);
          if (s > best.score) {
            best = { text: t, score: s, name: v.name };
            if (s > 22 && !shownPreview) {
              // Good candidate: show preview
              showPreview(v.canvas);
              shownPreview = true;
            }
          }
          if (typeof onProgress === 'function') onProgress(i+1, variants.length, v.name, t, s);
        } catch (e) {
          // Ignore individual variant errors
        }
        // Yield to UI
        await new Promise(r => setTimeout(r, 0));
      }
      return best;
    }

    async function solveImageElement(imageEl, abortRef) {
      setSolution('…');
      setStatus('Preprocessing...');
      const baseCanvas = drawToCanvas(imageEl);
      let variants = prepareVariants(baseCanvas);
      lastVariants = variants;

      const start = performance.now();

      // Race with a 15s timeout
      let timeoutId;
      const result = await Promise.race([
        (async () => {
          let lastMsgTime = 0;
          const best = await solveCanvasWithVariants(variants, (i, total, name, t, s) => {
            const now = performance.now();
            if (now - lastMsgTime > 120) {
              setStatus(`Trying variant ${i}/${total}: ${name}\nCandidate: ${t || '∅'} (score ${s.toFixed(1)})`);
              lastMsgTime = now;
            }
            if (t && s > 18) {
              setSolution(t);
            }
          }, abortRef);
          return best;
        })(),
        new Promise(resolve => {
          timeoutId = setTimeout(() => {
            resolve({ text: '', score: -1e9, name: 'timeout' });
          }, 15000);
        })
      ]);

      clearTimeout(timeoutId);
      const elapsed = ((performance.now() - start) / 1000).toFixed(2);
      if (result.name === 'timeout') {
        setStatus(`Timed out after ${elapsed}s. Best candidate shown if found.`);
      } else {
        setStatus(`Done in ${elapsed}s. Best variant: ${result.name}`);
      }
      if (result.text && result.text !== '…') {
        setSolution(result.text);
      } else if (solutionEl.textContent === '…' || !solutionEl.textContent || solutionEl.textContent === '—') {
        setSolution(result.text || ''); // if empty, show —
        if (!result.text) setSolution(''); // will render as —
      }
    }

    async function loadImage(src) {
      return new Promise((resolve, reject) => {
        const im = new Image();
        im.crossOrigin = 'anonymous';
        im.onload = () => resolve(im);
        im.onerror = (e) => reject(e);
        im.src = src;
      });
    }

    async function displayAndSolve(src) {
      abortSolve.flag = true; // cancel previous
      await new Promise(r => setTimeout(r, 10));
      abortSolve = { flag: false };

      setStatus('Loading image...');
      setSolution('—');
      try {
        img.src = src;
        await new Promise((res, rej) => {
          img.onload = () => res();
          img.onerror = (e) => rej(e);
        });
        setStatus('Image loaded. Solving...');
        solveImageElement(img, abortSolve);
      } catch (e) {
        setStatus('Failed to load image (CORS or invalid URL). Using sample instead.');
        const sample = generateSampleCaptcha();
        img.src = sample.dataUrl;
        img.onload = () => solveImageElement(img, abortSolve);
      }
    }

    // Wire UI
    $('loadBtn').addEventListener('click', () => {
      const u = urlInput.value.trim();
      if (!u) return;
      const href = new URL(location.href);
      href.searchParams.set('url', u);
      history.replaceState({}, '', href);
      displayAndSolve(u);
    });
    $('solveBtn').addEventListener('click', () => {
      if (!img.src) return;
      solveImageElement(img, abortSolve);
    });
    $('sampleBtn').addEventListener('click', () => {
      const sample = generateSampleCaptcha();
      urlInput.value = sample.dataUrl;
      const href = new URL(location.href);
      href.searchParams.delete('url');
      history.replaceState({}, '', href);
      displayAndSolve(sample.dataUrl);
    });
    $('togglePreview').addEventListener('click', () => {
      previewCanvas.classList.toggle('hidden');
    });
    $('downloadCanvas').addEventListener('click', () => {
      const a = document.createElement('a');
      a.href = previewCanvas.toDataURL('image/png');
      a.download = 'processed.png';
      a.click();
    });

    // Initialize
    (async function init() {
      const paramUrl = qs.get('url');
      if (paramUrl) {
        urlInput.value = paramUrl;
        displayAndSolve(paramUrl);
      } else {
        const sample = generateSampleCaptcha('X7G2Q');
        urlInput.value = sample.dataUrl;
        displayAndSolve(sample.dataUrl);
      }
    })();
  </script>
</body>
</html>